{"name":"Lanzafame.GitHub.io","tagline":"","body":"The JVM on AWS Burstable Instances\r\n\r\n### Introduction\r\n\r\nSo the long awaited answer. So I reread what I said, and what I did fail to mention was that this is only the case with burstable instances, so your t2 instances on AWS.\r\n\r\nSo using the specs of the AWS CPUs (Intel Xeon 2.5GHz (2.2GHz turbo mode)), I am hazarding a guess that AWS uses mostly this particular CPU (http://intel.ly/1P8VeKX) I could be wrong but for this exercise it doesn't really matter. So according to this article (http://amzn.to/1PrqJM8), if you are using a t2.micro instance, you have 6 CPU credits/hour at your disposal, which equates to 10% of a CPU core. If you are below the 10% you simple accrue the 6 credits, allowing for far higher CPU usage at a later time. If however you are over that 10%, you start to spend those credits, at a rate that is dependent on how much of the CPU you are utilizing.\r\n\r\n### Method\r\n\r\nSo I ran a test this afternoon, [scripts are here][test gists]. They simply sleep the thread for 40 seconds, then print a number from a list of strings. To get a sense for how consistent the CPU usage was for each script, I looped them with [this][loop script]. The aim of this test was to see what effect the JVM had on CPU usage and therefore the cost of running Java on AWS.\r\n\r\n### Results\r\n\r\nHere are the [results][aws results]. The red/orange line are the CPU Utilization (CU) of the Golang/Java instances respectively (axis on the left). The brown/purple lines are the CPU credit usage (CCU) for Golang and Java respectively (axis on the right).\r\n\r\n### Discussion\r\n\r\nStraight out, the CUU for Java is at 0.01, so not very much but notice that CUU for the Golang instance is at 0. The CU for the Java instance is constant, with an initial spike. I imagine the spike is the JVM booting up and it seems that it didn't shut down before the next exec was called each time, which is interesting (would love to hear any suggestions as to why this is). In regards to the Golang instance, the regular spikes in CU are caused by garbage collection (I used the Amazon Linux AMI, which uses Go 1.4, the version before the GC was overhauled).\r\n\r\n\r\n### Questions\r\n\r\nI will do some further tests to see whether more computation heavy programs require more from the JVM. Obviously I will need to avoid anything that triggers JVM Hotspot, so something like a router receiving multiple different requests.\r\n\r\n### Conclusion\r\n\r\n> 0.01CUU x 24hr = 0.24 CPU credits\r\n\r\nFor this test, there is a difference but not enough to make considering a non-JVM stack if you are already running one. If you are not running a JVM stack, why would you go there ;).\r\n\r\n[test gists]: http://bit.ly/1OATLf9\r\n[loop script]: http://bit.ly/1RXDO6J\r\n[aws results]: http://bit.ly/1ZQuypp","google":"UA-59567647-1","note":"Don't delete this file! It's used internally to help with page regeneration."}